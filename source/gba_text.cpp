#include "gba_text.h"
/*
unsigned short textMap[] =
{
	// Every two lines is a new line in the background
	0x0004, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001b, 0x0016,
	0x001b, 0x0008, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,

	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,

	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,

	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,

	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,
};*/

/*
void TextInit(TextObj a_textObj)
{
	for (s32 i = 0; i < TEXT_MAP_SIZE; i++)
	{
		a_textObj.map[i] = 0x0004;
	}
	unsigned short LookUpTable[] =
	{
		0x0000,	//Blank
		0x0001,	//A
		0x0002,	//B
		0x0003,	//C
		0x0004,	//D
		0x0005,	//E
		0x0006,	//F
		0x0007,	//G
		0x0008,	//H
		0x0009,	//I
		0x000A,	//J
		0x000B,	//K
		0x000C,	//L
		0x000D,	//M
		0x000E,	//N
		0x000F,	//O
		0x0010,	//P
		0x0011,	//Q
		0x0012,	//R
		0x0013,	//S
		0x0014,	//T
		0x0015,	//U
		0x0016,	//V
		0x0017,	//W
		0x0018,	//X
		0x0019,	//Y
		0x001A,	//Z
	};

	for (s32 i = 0; i < DEFUALT_LOOOKUP_TABLE_SIZE; i++)
	{
		if (i < 26)
		{
			a_textObj.lookup[i] = LookUpTable[i];
		}
		else
		{
			a_textObj.lookup[i] = LookUpTable[0];
		}

	}
}

void TextSetPal(TextObj a_textObj, const unsigned short* a_pal, const unsigned short a_palLen)
{
	memcpy(palette_bg_block_address(a_textObj.palBlockAddress), a_pal, a_palLen);
}

void TextSetTiles(TextObj a_textObj, const unsigned short* a_tiles, const unsigned short a_tilesLen)
{
	memcpy(tile_block_address(a_textObj.tileBlockAddress), a_tiles, a_tilesLen);
}

void TextSetMap(TextObj a_textObj)
{
	memcpy(tileMap_block_address(a_textObj.mapBlockAddress), a_textObj.map, TEXT_MAP_SIZE);
}

void TextPrint(TextObj a_textObj, fixed a_x, fixed a_y, char * a_string)
{
	//fixed x = int2fix(32) * a_x;
	//fixed y = int2fix(32) * a_y;
	//
	//u8 incerment = 0;
	//while (*a_string)
	//{
	//	a_textObj.map[((fix2int(y) * 32) + fix2int(x)) + incerment] = 0x0001;
	//	incerment++;
	//}
	//
	//TextSetMap(a_textObj);

	for (s32 i = 0; i < 5; i++)
	{
		a_textObj.map[i] = 0x001b;
	}
	memcpy(tileMap_block_address(16), a_textObj.map, 4096);
	//a_textObj.map[0] = 0x004;
	//TextSetMap(a_textObj);
}


void TextInit(TextObj a_textObj)
{
	for (s32 i = 0; i < TEXT_MAP_SIZE; i++)
	{
		a_textObj.map[i] = 0x0001;
	}
}

void TextSetPal(TextObj a_textObj, const unsigned short * a_pal, const unsigned short a_palLen)
{
}

void TextSetTiles(TextObj a_textObj, const unsigned short * a_tiles, const unsigned short a_tilesLen)
{
}

void TextSetMap(TextObj a_textObj)
{
}
*/